{
    "collab_server" : "",
    "contents" : "# Script to parse the annotations:\n# - Assign a unique id to each region\n# - Remove overlapping regions\n# - Create a metadata file with all annotations\n# - Remove weird chromosomes\n\n# Input:\n# - annotation files in BED format\n#     Example: chr1    4284766 4284898 ENSMUSG00000025900      0       -\n# Output:\n# - filtered annotation files in BED4 format\n#     Example: chr1    4284766 4284898 genebody_1\n\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(GenomicRanges)\n# library(data.table)\nlibrary(corrplot)\n\n# source('/Users/ricard/scMT/data_postpro/annos_mm10/scripts/utils.R')\n\n####################\n## Define options ##\n####################\n\n\n# I/O\nio <- list()\nio$in.folder <- \"/Users/ricard/NOMe-seq/data/feat/merged/unfilt\"\nio$out.folder <- \"/Users/ricard/NOMe-seq/data/feat/merged/filt\"\n\n# Options\nopts <- list()\nopts$anno <- \"all\"\nopts$chr_list <- str_c(\"chr\",c(1:19,\"X\",\"Y\"))\n\n###############################\n## Load the genomic contexts ##\n###############################\n\n# The data is accepted in the following formats:\n# BED3: chrom, start, end \n# BED4: chrom, start, end, name\n# BED6: chrom, start, end, name, score, strand\n\n# Select input genomic contexts\nif (opts$anno == \"all\") {\n  opts$in.files <- list.files(path=io$in.folder, pattern = \"\\\\.bed$\")\n  opts$anno <- sapply(str_split(opts$in.files,\"\\\\.\"),\"[[\", 1)\n} else {\n  opts$in.files <- str_c(opts$anno,\".bed\")\n}\n\ndata <- list()\ndata_gr <- list()\nfor (anno in opts$anno) {\n  \n  # Load data\n  print(sprintf(\"Loading %s\",anno))\n  data[[anno]] <- read.table(str_c(io$in.folder,\"/\",anno,\".bed\"), stringsAsFactors=F) %>% tbl_df\n  if (ncol(data[[anno]]) == 3)\n    colnames(data[[anno]]) <- c(\"chr\",\"start\",\"end\") \n  if (ncol(data[[anno]]) == 4)\n    colnames(data[[anno]]) <- c(\"chr\",\"start\",\"end\",\"name\") \n  if (ncol(data[[anno]]) == 6)\n    colnames(data[[anno]]) <- c(\"chr\",\"start\",\"end\",\"name\",\"score\",\"strand\") \n  \n  # Remove weird chromosoms\n  data[[anno]] <- data[[anno]] %>% filter(chr %in% opts$chr_list)\n  \n  # Create GRanges objects\n  data_gr[[anno]] = makeGRangesFromDataFrame(data[[anno]][,c(\"chr\",\"start\",\"end\")], start.field=\"start\", end.field=\"end\", seqnames.field=\"chr\")\n  \n  # If some annotation is already present, use it, otherwise create a unique id for each site\n  if ( (ncol(data[[anno]]) == 6) | (ncol(data[[anno]]) == 4) ) {\n    # If some gene names are duplicated then \n    if (!sum(duplicated(data[[anno]]$name))==0) {\n      tmp <- table(factor(data[[anno]]$name, levels=unique(data[[anno]]$name)))\n      data_gr[[anno]]$name <- unlist(sapply(names(tmp), function(i) \n        if (tmp[i] > 1) {\n          str_c(i,\"_\",1:tmp[i])\n        } else {\n          i\n        }, simplify=FALSE)\n      )\n    } else {\n      data_gr[[anno]]$name <- data[[anno]]$name\n    }\n  } else {\n    data_gr[[anno]]$name <- str_c(anno,\"_\",1:length(data_gr[[anno]]))\n  }\n  \n}\n\n\n#####################\n## Filter the data ##\n#####################\n\n# Remove overlapping ranges\n# a <- data_gr[[anno]][!is.na(findOverlaps(data_gr[[anno]], type=\"within\", select=\"arbitrary\", drop.self=T))]\n\n# Generate metadata dataframe by combining all genomic contexts\nmetadata <- list()\nfor (anno in opts$anno) {\n  metadata[[anno]] <- data.frame(chr=seqnames(data_gr[[anno]]), start=start(data_gr[[anno]]), \n                                 end=end(data_gr[[anno]]), id=data_gr[[anno]]$name, name=anno)\n}\n\n####################################\n## Calculate genome-wide coverage ##\n####################################\n\ngenome_stats <- read.table(\"/Users/ricard/data/mm10_regulation/mm10.genome\",header=F);\ncolnames(genome_stats) <- c(\"chr\",\"size\")\ntotal_n <- sum(as.numeric(genome_stats$size))\nov <- c()\nfor (anno in opts$anno) {\n  anno_nonov <- reduce(data_gr[[anno]])\n  ov[anno] <- sum(width(anno_nonov))/total_n\n  print(sprintf(\"Genome-wide coverage for %s: %0.4f\",anno,ov[anno]))\n}\n\n#######################\n## Calculate overlap ##\n#######################\n\nov_df <- matrix(nrow=length(opts$anno), ncol=length(opts$anno))\ncolnames(ov_df) <- opts$anno\nrownames(ov_df) <- opts$anno\n\nfor (i in 1:length(opts$anno)) {\n  for (j in 1:length(opts$anno)) {\n\n    anno1 = data_gr[[opts$anno[i]]]\n    anno2 = data_gr[[opts$anno[j]]]\n\n    # For simplicity, remove overlapping regions within the same dataset\n    anno1 <- reduce(anno1)\n    anno2 <- reduce(anno2)\n\n    # Now I am obtaining only the fraction of nucleotides of the overlaps\n    # I also want the non-overlaps\n    ov = findOverlaps(query=anno1, subject=anno2, type='any')\n    intersect = pintersect(anno1[queryHits(ov),], anno2[subjectHits(ov),])\n\n    # Compute fraction of nucleotides that overlap\n    ov_ij <- sum(width(intersect))/sum(width(anno1))\n    ov_ji <- sum(width(intersect))/sum(width(anno2))\n\n    if (ov_ij > 1.0 | ov_ji > 1.0)\n      stop(\"Fraction overlap is higher than 1\")\n\n    ov_df[i,j] <- ov_ij\n    ov_df[j,i] <- ov_ji\n  }\n}\n\n# Generate correlation plot\ncol <- colorRampPalette(c(\"#67001F\", \"#B2182B\", \"#D6604D\", \"#F4A582\", \"#FDDBC7\", \"#FFFFFF\", \"#D1E5F0\", \"#92C5DE\", \"#4393C3\", \"#2166AC\", \"#053061\"))\npng(filename=\"/Users/ricard/git/gastrulation/annotations/overlap.png\")\ncorrplot(ov_df, method='color', order=\"original\", hclust.method = c(\"average\"), \n         title=\"\", cl.lim=c(0,1), cl.cex=0.9, tl.cex=1.0, tl.col=\"black\", col=col(200), mar=c(0,0,0,0))\ndev.off()\n\n##################\n## Save results ##\n##################\n\n# Create output directory\nif (!dir.exists(io$out.folder)) { dir.create(io$out.folder) }\n\n# Save data\nfor (anno in opts$anno)\n  write.table(metadata[[anno]], file=sprintf(\"%s/%s.bed\",io$out.folder,anno), quote=F, sep=\"\\t\", row.names=F, col.names=F)\n\n# Save metadata\nwrite.table(rbindlist(metadata) %>% tbl_df %>% arrange(chr,start,end), \n            file=sprintf(\"%s/metadata.txt\",io$out.folder), quote=F, sep=\"\\t\", row.names=F, col.names=F)\n\n",
    "created" : 1484254903440.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2682770134",
    "id" : "CC5178A4",
    "lastKnownWriteTime" : 1484244129,
    "last_content_update" : 1484255004684,
    "path" : "~/NOMe-seq/data/feat/filter.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}