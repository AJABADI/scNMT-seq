---
title: "NMT-Seq: Association between accessibility heterogeneity and expression"
output: 
  BiocStyle::html_document: 
    fig_width: 12
    fig_height: 8
---

```{r echo=FALSE, include=FALSE}
# devtools::install_github("andreaskapou/BPRMeth-devel")
suppressPackageStartupMessages(library(BPRMeth))
suppressPackageStartupMessages(library(scater))
suppressPackageStartupMessages(library(purrr))
suppressPackageStartupMessages(library(weights))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(gridExtra))
suppressPackageStartupMessages(library(scales))
suppressPackageStartupMessages(library(grid))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(truncnorm))
```

```{r echo=FALSE, include=FALSE}
# Define ggplot2 theme for scatter plots
scatter_theme <- function(){
  p <- theme(
      plot.title=element_text(size=28, face='bold', margin=margin(0,0,10,0), hjust=0.5),
      plot.subtitle = element_text(size=20, face='bold', margin=margin(0,0,10,0), hjust=0.5),
      axis.text=element_text(size=rel(1.75), color='black'),
      axis.title=element_text(size=rel(1.95), color='black'),
      axis.title.y = element_text(margin=margin(0,10,0,0)),
      axis.title.x = element_text(margin=margin(10,0,0,0)),
      legend.position="right",
      panel.border=element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_blank()
    )
}

# Scatter plot function
scatter_plot <- function(data, xlabel="", ylabel="", title="", subtitle="", lm=FALSE, loess = FALSE) {
  p <- ggplot(data, aes_string(x=names(data)[1], y=names(data)[2], col=names(data)[3])) +
    labs(x=xlabel, y=ylabel, title=title, subtitle=subtitle) +
    geom_point(shape = 16, size = 2.5, show.legend = FALSE, alpha = .55) + 
    scatter_theme() + 
    scale_color_gradient(low = "#0091ff", high = "#f0650e")
  if (lm){
    if (loess){ p <- p + geom_smooth() }#+ scale_x_continuous(trans = "log1p")
    else{ p <- p + geom_smooth(method='lm') }
  }
}

# Define ggplot2 boxplot theme for boxplots
boxplot_theme <- function() {
  p <- theme(
    plot.title = element_text(size=30, hjust=0.5, margin=margin(0,0,20,0)),
    axis.title.y = element_text(colour="black", size=20, vjust=1.5),
    axis.title.x = element_text(colour="black", size=20, vjust=1.5, margin=margin(15,0,0,0)),
    axis.text.x = element_text(colour="black",size=rel(1.6)),
    axis.text.y = element_text(colour="black",size=rel(1.6)),
    axis.line = element_line(colour="black", size=rel(0.7)),
    axis.ticks.x = element_line(colour="black", size=rel(0.8)),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    panel.grid = element_blank(),
    legend.position="none",
    legend.text=element_text(size=15),
    legend.title=element_blank(),
    legend.background=element_blank(),
    panel.border = element_blank()
  )
}

# Define ggplot2 boxplot theme for boxplots
barplot_theme <- function() {
  p <- theme(
    plot.title = element_text(size=30, hjust=0.5, margin=margin(0,0,20,0)),
    axis.title.y = element_text(colour="black", size=20, vjust=1.5),
    axis.title.x = element_text(colour="black", size=20, vjust=1.5, margin=margin(15,0,0,0)),
    axis.text.x = element_text(colour="black",size=rel(1.6)),
    axis.text.y = element_text(colour="black",size=rel(1.6)),
    axis.line = element_line(colour="black", size=rel(0.7)),
    axis.ticks.x = element_line(colour="black", size=rel(0.8)),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    panel.grid = element_blank(),
    legend.position="right",
    legend.text=element_text(size=13),
    legend.title=element_text(size=18),
    legend.background=element_blank(),
    panel.border = element_blank()
  )
}

# Define ggplot2 boxplot theme for multiple boxplots
barplot_multi_theme <- function() {
  p <- theme(
    plot.title = element_text(size=30, hjust=0.5, margin=margin(0,0,20,0)),
    axis.title.y = element_text(colour="black", size=20, vjust=1.5),
    axis.title.x = element_text(colour="black", size=20, vjust=1.5, margin=margin(15,0,0,0)),
    axis.text.x = element_text(colour="black",size=rel(1.2)),
    axis.text.y = element_text(colour="black",size=rel(1.5)),
    axis.line = element_line(colour="black", size=rel(0.7)),
    axis.ticks.x = element_line(colour="black", size=rel(0.8)),
    axis.ticks.y = element_blank(),
    panel.background = element_blank(),
    panel.grid = element_blank(),
    legend.position="right",
    legend.text=element_text(size=13),
    legend.title=element_text(size=18),
    legend.background=element_blank(),
    panel.border = element_blank()
  )
}
```

<!-- # Parse and filter data -->
```{r echo=FALSE, include=FALSE}
# Data
io                     <- list()
io$base_dir            <- "scNMT_data_EB_dir"
io$out_dir             <- "/out_dir/"
io$rna_file            <- paste0(io$base_dir, "/rna/parsed/sceset.rds")
io$acc_file_rate       <- paste0(io$base_dir, "/acc/parsed/acc_data.tsv.gz")
io$acc_file            <- paste0(io$base_dir, "/acc/parsed/profiles/cons_cluster_prom_200_200_basis13_GpCcov10_bic2_cellcov0.6.rds")
io$genelist_dir        <- paste0(io$base_dir, "/metadata")
io$plur_genes_file     <- paste0(io$genelist_dir, "/pluripotency_extended.tsv")
io$h3k4me3_genes_file  <- paste0(io$genelist_dir, "/H3K4me3.bed")
io$h3k27me3_genes_file <- paste0(io$genelist_dir, "/H3K27me3.bed")

opts                   <- list()
opts$annos             <- c("prom_200_200")
opts$min.weight        <- 10      # Minimum weight per feature (met coverage)
opts$min.s             <- 10      # minimum number of samples to do the correlation
opts$gene_window       <- 5e3     # window length for the overlap between genes and features
opts$threshold         <- 5e-2    # threshold for significant hits
opts$quan_seq          <- seq(0, 1, length.out = 6) # Discretization steps
opts$axis_labels       <- paste0(seq(1,5))     # Discretization steps
```

<!-- # Load scRNA data -->
```{r load_rna, echo=FALSE, include=FALSE, warning=FALSE, message=FALSE}
# Load expression as SCESet object
sceset        <- readRDS(file = io$rna_file)
# Create data.table
rna_dt        <- exprs(sceset) %>% t %>% as.data.table(keep.rownames = "sample") %>% melt(id.vars = "sample", value.name = "expr", variable.name = "gene")
# Compute summary statistics for each gene across cells
rna_all_stats <- rna_dt[, .(mean_expr = mean(expr), median_expr = median(expr), var_expr = var(expr), sd_expr = sd(expr), cv_expr = sd(expr)/mean(expr)), by = gene]
N_cells       <- length(unique(rna_dt$sample))  # Number of unique cells
rna_all_stats <- rna_all_stats[, cv_expr := log2((1 + 1/(4 * N_cells)) * cv_expr)]  # Correct CV empirically
# Extract biological variance, i.e. overdispersion
rna_all_stats <- rna_all_stats[, overdispersion := fData(sceset)$bioVar]
# Extract gene coordinates metadata to do the overlap
rna_metadata  <- fData(sceset) %>% tibble::rownames_to_column("gene") %>% as.data.table %>% .[,c("chr", "start", "end", "gene", "ens_id")]  %>% .[, chr := as.factor(sub("chr", "", chr))] %>% setnames("ens_id", "id")
# Merge rna data with metadata
rna_all_stats <- merge(rna_metadata[, c("chr", "id", "gene")], rna_all_stats, by = c("gene")) # Merge using all samples
rna_dt        <- merge(rna_metadata[, c("chr", "id", "gene")], rna_dt, by = c("gene"))        # Merge using only samples that pass filtering
rm(sceset, N_cells)
```

<!-- # Load acc rate data -->
```{r load_acc_rate, eval=TRUE, echo=FALSE, include=FALSE, warning=FALSE, message=FALSE}
# Load accessibility data
acc_rate   <- fread(sprintf("zcat < %s", io$acc_file_rate)) %>% as.data.table %>% .[anno %in% opts$annos] %>% .[, rate := rate + rtruncnorm(.N, a = 0, b = Inf, mean = 0, sd = 0.01 )]
# Keep only covered regions
acc_rate   <- acc_rate[weight >= opts$min.weight] 
# Filter regions not covered across cells
keep_sites <- acc_rate[,.(n = .N), by = c("id")] %>% .[n >= opts$min.s] %>% .$id  
acc_rate   <- acc_rate[id %in% keep_sites]
# Compute summary statistics
acc_rate_stats <- acc_rate[, .(mean_acc = mean(rate), median_acc = median(rate), var_acc = var(rate), sd_acc = sd(rate)), by = id] 
rm(keep_sites)
```

<!-- # Load acc profile data -->
```{r load_acc_prof, echo=FALSE, include=FALSE, warning=FALSE, message=FALSE}
# Load accessibility data
acc_profile  <- readRDS(io$acc_file) %>% .[cells > opts$min.s] 
# Make clusters column as factor and keep accessibility groups with more than 30 genes in each cluster
acc_profile <- acc_profile %>% .[, factor_clusters := factor(clusters)] %>% .[, N := .N, by = clusters] %>% .[N > 30]
# Merge with expression data
accrna_prof <- merge(rna_all_stats, acc_profile, by = c("id")) %>% setorder(clusters) 
rm(acc_profile)
```

<!-- # Merge all data in one data.table object -->
```{r merge_dt, echo=FALSE, include=FALSE, warning=FALSE, message=FALSE}
# Merge data with rate
accrna <- merge(accrna_prof, acc_rate_stats, by = c("id")) %>% setorder(clusters)
# Create accessibility variability levels using quartiles
accrna <- accrna %>% .[, acc_var_levels := cut(abs(sd_acc), breaks = quantile(abs(sd_acc), probs = opts$quan_seq), labels = opts$axis_labels, include.lowest = TRUE)]
# Create mean expression levels
accrna <- accrna %>% .[, scaled_expr := BPRMeth:::.minmax_scaling(mean_expr, fmin = 0, fmax = 1)] %>% .[, scaled_mean_expr_levels := cut(scaled_expr, seq(0 , 1, length.out = 6), labels=c(1:5), include.lowest = TRUE)]
# Create mean expression levels
accrna <- accrna %>% .[, mean_expr_levels := cut(mean_expr, breaks = quantile(mean_expr, probs = opts$quan_seq), labels = opts$axis_labels, include.lowest = TRUE)]
# Create discrete expression levels
opts$discr_labels <- c("Zero Expr", "Low Expr", "Medium Expr", "High Expr")     # Discretization steps
accrna <- accrna %>% .[, discr_expr_levels := cut(mean_expr, breaks = c(0 , 0.001, 2, 6, 20), labels = opts$discr_labels, include.lowest = TRUE)]
```

# Accessibility heterogeneity and expression relationship

## Using likelihood information and BIC 
To quantify the heterogeneity of accessibility patterns around promoters we use the likelihood information from the fitted profiles. Essentially we try and cluster the accessibility profiles of a gene across all cells. Initially, we start with one cluster, and then we increase the number of clusters $k$, by also computing the Bayesian Information Criterio (BIC). The BIC helps us to perform model selection and we choose the number of clusters k with the lowest BIC. 
So genes with low number of clusters are more conserved in terms of their accessibility profiles. This is because with a small number of clusters we could explain all the information encoded in the profile of each cell. The region for the accesibility profiles is $\pm 200$ around TSS. 

## Association with mean expression
We observe that accessibility heterogeneity around promoter regions is negatively correlated with mean expression levels, i.e. genes with tightly controlled chromatin accessibility patterns have higher expression levels across cells. However when looking at accessibility rate variability and mean expression we cannot capture this signal, and they seem uncorrelated.
```{r associate, echo=FALSE, warning=FALSE, message=FALSE}
# Acc profile heterogeneity - Mean expression association
p <- ggplot(accrna[,c("factor_clusters", "mean_expr", "N")], aes(x=factor_clusters, y=mean_expr)) +
  geom_boxplot(alpha=0.7, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  stat_summary(fun.y = function(x){ xx <- min(x); return(xx - 0.7)}, aes(label = paste0("N=", as.character(N))), geom='text', col='black', size = 5) +
  labs(title=NULL, x="Clusters (i.e. heterogeneity)", y="Mean expression") + boxplot_theme()
p

# Acc rate variance - Mean expression association
p <- ggplot(accrna[,c("acc_var_levels", "mean_expr")], aes(x=acc_var_levels, y=mean_expr)) +
  geom_boxplot(alpha=0.7, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  labs(title=NULL, x="Accessibility rate variance", y="Mean expression") + boxplot_theme()
p
rm(p)
```

Below we show the relationship between mean accessibility rate and mean expression levels across cells (semi-bulk data), and as expected we have a positive association between these layers.
```{r associate_3, echo=FALSE, warning=FALSE, message=FALSE}
# Acc rate - Mean expression association
p <- scatter_plot(accrna[, c("mean_expr", "mean_acc", "var_acc")], xlabel = "Mean expression", ylabel = "Accessibility rate", title = "", subtitle = paste0("Pearson's r = ", round(cor(accrna$mean_acc, accrna$mean_expr), 2)), lm = TRUE)
p
rm(p)
```

## Association with expression variability
Let's see first the relationship of mean expression with variance, CV and overdispersion, respectively (i.e. look at the left column). For the mean-CV relationship we obtain the know relationship, where lowly expressed genes have higher coefficient of variation. On the other hand, for the mean-variance relationship we obtain a bell-shape curve, where moderately expressed genes have the highest variance, mostly due to dropouts. The next two columns show the relationship between Acc heterogeneity and the different summary statistics for gene expression, which are shown in the leftmost column.
```{r acc_var_expr, echo=FALSE, warning=FALSE, message=FALSE,fig.width=18, fig.height=14}
# Expression mean - variance relationship
p01 <- scatter_plot(accrna[, c("mean_expr", "var_expr", "clusters")], xlabel = "Mean expression", ylabel = "Expr variance", title = "", lm = TRUE, loess = TRUE)
# Expression mean - CV relationship
p02 <- scatter_plot(accrna[, c("mean_expr", "cv_expr", "clusters")], xlabel = "Mean expression", ylabel = "Expr log2CV", title = "", lm = TRUE, loess = TRUE)
# Expression mean - overdispersion relationship
p03 <- scatter_plot(accrna[, c("mean_expr", "overdispersion", "clusters")], xlabel = "Mean expression", ylabel = "Expr overdisp", title = "", lm = TRUE, loess = TRUE)
# Acc heterogeneity - Expression variance association
p1 <- ggplot(accrna[,c("factor_clusters","var_expr", "N")], aes(x=factor_clusters, y=var_expr)) +
  geom_boxplot(alpha=0.8, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  stat_summary(fun.y = function(x){ xx <- min(x); return(xx - 0.7)}, aes(label = paste0("N=", as.character(N))), geom='text', col='black', size = 5) +
  labs(title=NULL, x="Clusters (i.e. heterogeneity)", y="Expression variance") + boxplot_theme()
# Acc heterogeneity - Expression CV association
p2 <- ggplot(accrna[,c("factor_clusters","cv_expr", "N")], aes(x=factor_clusters, y=cv_expr)) +
  geom_boxplot(alpha=0.8, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  stat_summary(fun.y = function(x){ xx <- -4; return(xx - 0.7)}, aes(label = paste0("N=", as.character(N))), geom='text', col='black', size = 5) +
  labs(title=NULL, x="Clusters (i.e. heterogeneity)", y="Expression log2 CV") + boxplot_theme()
# Acc heterogeneity - Expression overdispersion association
p3 <- ggplot(accrna[,c("factor_clusters","overdispersion", "N")], aes(x=factor_clusters, y=overdispersion)) +
  geom_boxplot(alpha=0.8, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  stat_summary(fun.y = function(x){ xx <- -2; return(xx - 0.7)}, aes(label = paste0("N=", as.character(N))), geom='text', col='black', size = 5) +
  scale_y_continuous(limits = c(-3, 2)) +
  labs(title=NULL, x="Clusters (i.e. heterogeneity)", y="Expression overdisp") + boxplot_theme()

# Acc rate heterogeneity - Expression variance association
p12 <- ggplot(accrna[,c("acc_var_levels","var_expr")], aes(x=acc_var_levels, y=var_expr)) +
  geom_boxplot(alpha=0.8, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  labs(title=NULL, x="Accessibility rate variance", y="Expression variance") + boxplot_theme()
# Acc rate heterogeneity - Expression CV association
p22 <- ggplot(accrna[,c("acc_var_levels","cv_expr")], aes(x=acc_var_levels, y=cv_expr)) +
  geom_boxplot(alpha=0.8, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  labs(title=NULL, x="Accessibility rate variance", y="Expression log2 CV") + boxplot_theme()
# Acc rate heterogeneity - Expression overdispersion association
p32 <- ggplot(accrna[,c("acc_var_levels","overdispersion")], aes(x=acc_var_levels, y=overdispersion)) +
  geom_boxplot(alpha=0.8, outlier.shape=NA, fill="#00BFC4") + geom_hline(yintercept=0, colour="black", linetype="dashed") +
  scale_y_continuous(limits = c(-3, 2)) +
  labs(title=NULL, x="Accessibility rate variance", y="Expression overdisp") + boxplot_theme()

pp <- cowplot::plot_grid(p01, p1, p12, p02, p2, p22, p03, p3, p32, label_size = 30, labels="AUTO", ncol = 3, nrow = 3, rel_widths = c(1, 1, 1))
plot(pp)
rm(p1, p2, p3, p01, p02, p03, p12, p22, p32, pp)
```

# GO analysis
Here we perform Gene Ontology analysis to see whether specific clusters of genes are enriched for specific pathways.
```{r go_enr_list, echo=FALSE, warning=FALSE, message=FALSE, fig.width=12, fig.height=6}
io$reactomeFile  <- paste0(io$genelist_dir, "/mouse_v75_reactome.rds")
io$reactomeFile2 <- paste0(io$genelist_dir, "/AllPathways.txt")

# Read reactome file and change gene names to Upper case
reactome           <- readRDS(io$reactomeFile); colnames(reactome) <- toupper(colnames(reactome))
# Read pathways file to change from ID to description pathway
tmp                <- read.table(io$reactomeFile2, header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta      <- tmp[,2]; names(reactome_meta) <- tmp[,1]
rownames(reactome) <- stringr::str_replace_all(rownames(reactome), reactome_meta)
feature.sets       <- reactome  # Store results to the following object
opts$min.size      <- 10  # Filter feature sets with small number of features
feature.sets       <- feature.sets[rowSums(feature.sets)>=opts$min.size, ]
# Remove features that do not intersect between the feature sets and the data
accrna_tmp        <- copy(accrna)
features          <- intersect(toupper(accrna_tmp$gene), colnames(feature.sets))
foo_filt          <- accrna_tmp[,gene := toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]

# Melt and merge data to do the fisher's test
asd <- melt.data.table(as.data.table(feature.sets_filt, keep.rownames="pathway"), id.vars = "pathway", 
                       variable.name="gene", value.name="value") %>% merge(foo_filt[,c("gene","clusters")], allow.cartesian=T, by="gene")
# Get GO list for each cluster
go_list <- list()
for (c in unique(sort(asd$cluster))) {
  go_list[[c]] <- asd[,.(p=fisher.test(x=matrix(data=c(.SD[clusters==c & value==1,.N], .SD[clusters!=c & value==1,.N],
                                                       .SD[clusters==c & value==0,.N], .SD[clusters!=c & value==0,.N]), 
                                                nrow=2, ncol=2), alternative="greater")[["p.value"]]), by="pathway"] %>% 
    .[,padj:=p.adjust(p, method = "fdr")] %>% setorder(p)
  # Create a nice formatted table
  # print(knitr::kable(go_list[[c]][1:45], caption = paste0("GO enrichment: Cluster ", c)))
  
  # Convert pvalues to log scale (add a small regulariser to avoid numerical errors)
  tmp <- copy(go_list[[c]])
  tmp$log <- -log10(tmp$padj)
  #order according to significance
  tmp$pathway <- factor(tmp$pathway, levels = tmp$pathway[order(tmp$padj, decreasing = T)])
  p <- ggplot(tmp[1:38], aes(x=pathway, y=log)) +
    geom_point(size=5) +
    geom_hline(yintercept=-log10(opts$threshold), linetype="longdash", color = "red") +
    scale_color_manual(values=c("black","red")) +
    geom_segment(aes(xend=pathway, yend=0)) +
    ylab(expression(paste("-log"[10],"(",plain(q),"-value)"))) + coord_flip() +
    theme(axis.text.y = element_text(size=rel(0.9), hjust=1, color='black'),
      axis.text.x = element_text(size=rel(1.2), vjust=0.5, color='black'),
      axis.title.y=element_blank(), legend.position='none',
      panel.background = element_blank()
    )
  print(p)
}
rm(reactome, reactome_meta, tmp, p, asd, features, foo_filt, feature.sets_filt, accrna_tmp, feature.sets, c, go_list)
```

## GO analysis using variance of accessibility rate
Here we perform Gene Ontology analysis to see whether specific clusters of genes are enriched for specific pathways.
```{r go_enr_list_rate, echo=FALSE, warning=FALSE, message=FALSE, fig.width=12, fig.height=6}
io$reactomeFile  <- paste0(io$genelist_dir, "/mouse_v75_reactome.rds")
io$reactomeFile2 <- paste0(io$genelist_dir, "/AllPathways.txt")

# Read reactome file and change gene names to Upper case
reactome           <- readRDS(io$reactomeFile); colnames(reactome) <- toupper(colnames(reactome))
# Read pathways file to change from ID to description pathway
tmp                <- read.table(io$reactomeFile2, header=F, quote="", sep="\t", stringsAsFactors=F)[,c(1,2)]
reactome_meta      <- tmp[,2]; names(reactome_meta) <- tmp[,1]
rownames(reactome) <- stringr::str_replace_all(rownames(reactome), reactome_meta)
feature.sets       <- reactome  # Store results to the following object
opts$min.size      <- 10  # Filter feature sets with small number of features
feature.sets       <- feature.sets[rowSums(feature.sets)>=opts$min.size, ]
# Remove features that do not intersect between the feature sets and the data
accrna_tmp        <- copy(accrna)
features          <- intersect(toupper(accrna_tmp$gene), colnames(feature.sets))
foo_filt          <- accrna_tmp[,gene := toupper(gene)] %>% .[gene %in% features]
feature.sets_filt <- feature.sets[,features]

# Melt and merge data to do the fisher's test
asd <- melt.data.table(as.data.table(feature.sets_filt, keep.rownames="pathway"), id.vars = "pathway", 
                       variable.name="gene", value.name="value") %>% merge(foo_filt[,c("gene","acc_var_levels")], allow.cartesian=T, by="gene")
# Get GO list for each cluster
go_list <- list()
for (c in unique(sort(asd$acc_var_levels))) {
  go_list[[c]] <- asd[,.(p=fisher.test(x=matrix(data=c(.SD[acc_var_levels==c & value==1,.N], .SD[acc_var_levels!=c & value==1,.N],
                                                       .SD[acc_var_levels==c & value==0,.N], .SD[acc_var_levels!=c & value==0,.N]), 
                                                nrow=2, ncol=2), alternative="greater")[["p.value"]]), by="pathway"] %>% 
    .[,padj:=p.adjust(p, method = "fdr")] %>% setorder(p)
  # Create a nice formatted table
  # print(knitr::kable(go_list[[c]][1:45], caption = paste0("GO enrichment: Cluster ", c)))
  
  # Convert pvalues to log scale (add a small regulariser to avoid numerical errors)
  tmp <- copy(go_list[[c]])
  tmp$log <- -log10(tmp$padj)
  #order according to significance
  tmp$pathway <- factor(tmp$pathway, levels = tmp$pathway[order(tmp$padj, decreasing = T)])
  p <- ggplot(tmp[1:38], aes(x=pathway, y=log)) +
    geom_point(size=5) +
    geom_hline(yintercept=-log10(opts$threshold), linetype="longdash", color = "red") +
    scale_color_manual(values=c("black","red")) +
    geom_segment(aes(xend=pathway, yend=0)) +
    ylab(expression(paste("-log"[10],"(",plain(q),"-value)"))) + coord_flip() +
    theme(axis.text.y = element_text(size=rel(0.9), hjust=1, color='black'),
      axis.text.x = element_text(size=rel(1.2), vjust=0.5, color='black'),
      axis.title.y=element_blank(), legend.position='none',
      panel.background = element_blank()
    )
  print(p)
}
rm(reactome, reactome_meta, tmp, p, asd, features, foo_filt, feature.sets_filt, accrna_tmp, feature.sets, c, go_list)
```


# Histone marks
Here we perform Histone mark enrichment analysis to see whether specific clusters of genes are enriched for specific marks.
```{r hm_genelist, echo=FALSE, warning=FALSE, message=FALSE, results='asis',fig.width=12, fig.height=7}
# Read histone marks files
h3k4_genes <- fread(io$h3k4me3_genes_file) %>% as.data.table %>% .[, c("V1", "V2", "V3")] %>% setnames(c("chr", "start", "end")) %>% setkey(chr, start, end) %>% .[, chr := as.factor(sub("chr", "", chr))] %>% .[, id := paste0("hek4m3_", 1:.N)]
h3k27_genes <- fread(io$h3k27me3_genes_file) %>% as.data.table %>% .[, c("V1", "V2", "V3")] %>% setnames(c("chr", "start", "end")) %>% setkey(chr, start, end) %>% .[, chr := as.factor(sub("chr", "", chr))] %>% .[, id := paste0("h3k27me3_", 1:.N)]
# Get RNA metdata to do the overlapping with genes
rna_metadata_tmp <- rna_metadata[, c("chr", "start", "end", "gene")] %>%
  .[,c("start", "end") := list(start - opts$gene_window, start + opts$gene_window)] %>% setkey(chr, start, end)
# Do the overlap
ov_h3k4  <- foverlaps(h3k4_genes, rna_metadata_tmp, nomatch = 0) %>% .[,c("gene")] %>% unique
ov_h3k27 <- foverlaps(h3k27_genes, rna_metadata_tmp, nomatch = 0) %>% .[,c("gene")] %>% unique
ov_h3    <- Reduce(intersect, list(ov_h3k4$gene, ov_h3k27$gene)) %>% as.data.table %>% setnames(c("gene"))
# Total number of clusters k
cls      <- length(unique(accrna$clusters))
h3k4_c = h3k27_c = biv_c = unmark_c <- vector(mode = "numeric", length = cls)
for (i in 1:cls){  # Iterate over each cluster and extract number of genes related to each histone mark
  h3k4_c[i]   <- NROW(accrna[gene %in% ov_h3k4$gene & !(gene %in% ov_h3k27$gene) & clusters == i])
  h3k27_c[i]  <- NROW(accrna[gene %in% ov_h3k27$gene & !(gene %in% ov_h3k4$gene) & clusters == i])
  biv_c[i]    <- NROW(accrna[gene %in% ov_h3$gene & clusters == i])
  unmark_c[i] <- NROW(accrna[!(gene %in% ov_h3k27$gene | gene %in% ov_h3k4$gene) & clusters == i])
}

# Create object for plotting
dt <- data.table(Cluster = rep(paste0("C", seq(1:cls)), 4), 
                 Mark = c(rep("H3K4me3", cls), rep("H3K27me3", cls), rep("Bivalent", cls), rep("Unmarked", cls)), 
                 Proportion = c(as.integer(h3k4_c), as.integer(h3k27_c), as.integer(biv_c), as.integer(unmark_c)))
dt <- dt %>% .[, N := sum(Proportion), by = Cluster]

p <- ggplot(dt, aes(fill=Mark, y=Proportion, x=Cluster)) + geom_bar(stat="identity", position="fill", alpha=1) + 
  stat_summary(fun.y = function(x){ xx <- 0; return(xx - 0.05)}, aes(label = paste0("N=", as.character(N))), geom='text', col='black', size = 7) +
  #scale_fill_manual(values = c("tomato", "yellow2", "chartreuse3", "cornflowerblue")) 
  labs(x="Clusters", y="Relative Proportion", fill = "Histone mark") +
  scale_fill_discrete(name="Histone mark") + 
  scale_fill_brewer(palette = "Set3") + barplot_theme()
p
rm(h3k4_genes, h3k27_genes, rna_metadata_tmp, p, i, unmark_c, h3k4_c, h3k27_c, biv_c, cls)
```


## Histone marks by mean expression levels discretized
```{r hm_genelist_discr, echo=FALSE, warning=FALSE, message=FALSE, results='asis',fig.width=12, fig.height=6}
# Total number of clusters k
cls      <- length(unique(accrna$clusters))
disc_lev <- levels(accrna$discr_expr_levels)
h3k4_c = h3k27_c = biv_c = unmark_c <- vector(mode = "numeric", length = cls)
dt_all <- data.table(Cluster = character(), 
                 Mark = character(), 
                 Proportion = numeric(),
                 Mean_Level = factor())
for (i in 1:cls){  # Iterate over each cluster and extract number of genes related to each histone mark
  for (l in disc_lev){
    h3k4_c[i]   <- NROW(accrna[gene %in% ov_h3k4$gene & !(gene %in% ov_h3k27$gene) & clusters == i & discr_expr_levels == l])
    h3k27_c[i]  <- NROW(accrna[gene %in% ov_h3k27$gene & !(gene %in% ov_h3k4$gene) & clusters == i & discr_expr_levels == l])
    biv_c[i]    <- NROW(accrna[gene %in% ov_h3$gene & clusters == i & discr_expr_levels == l])
    unmark_c[i] <- NROW(accrna[!(gene %in% ov_h3k27$gene | gene %in% ov_h3k4$gene) & clusters == i & discr_expr_levels == l])
    # Create object for plotting
    dt <- data.table(Cluster = paste0("C", i), 
                   Mark = c("H3K4me3", "H3K27me3", "Bivalent", "Unmarked"), 
                   Proportion = c(as.integer(h3k4_c[i]), as.integer(h3k27_c[i]), as.integer(biv_c[i]), as.integer(unmark_c[i])),
                   Mean_Level = l)
    dt_all <- rbind(dt_all, dt)
  }
}
dt_all <- dt_all %>% .[, N := sum(Proportion), by = c("Cluster", "Mean_Level")]

p <- ggplot(dt_all, aes(fill=Mark, y=Proportion, x=Cluster)) + geom_bar(stat="identity", position="fill", alpha=1) + 
  facet_grid(. ~ Mean_Level) +
  stat_summary(fun.y = function(x){ xx <- 0; return(xx - 0.05)}, aes(label = paste0("N=", as.character(N))), geom='text', col='black', size = 3.7) +
  labs(x="Clusters", y="Relative Proportion", fill = "Histone mark") +
  scale_fill_discrete(name="Histone mark") + 
  scale_fill_brewer(palette = "Set3") + barplot_multi_theme() + theme(legend.position="none")
p
rm(p, i, l, unmark_c, h3k4_c, h3k27_c, biv_c, cls, disc_lev, dt, dt_all)
```

## Histone marks by mean expression levels quantile
```{r hm_genelist_quant, echo=FALSE, warning=FALSE, message=FALSE, results='asis',fig.width=13, fig.height=5.5}
# Total number of clusters k
cls      <- length(unique(accrna$clusters))
mean_lev <- length(unique(accrna$mean_expr_levels))
h3k4_c = h3k27_c = biv_c = unmark_c <- vector(mode = "numeric", length = cls)
dt_all <- data.table(Cluster = character(), 
                 Mark = character(), 
                 Proportion = numeric(),
                 Mean_Level = factor())
for (i in 1:cls){  # Iterate over each cluster and extract number of genes related to each histone mark
  for (l in 1:mean_lev){
    h3k4_c[i]   <- NROW(accrna[gene %in% ov_h3k4$gene & !(gene %in% ov_h3k27$gene) & clusters == i & mean_expr_levels == l])
    h3k27_c[i]  <- NROW(accrna[gene %in% ov_h3k27$gene & !(gene %in% ov_h3k4$gene) & clusters == i & mean_expr_levels == l])
    biv_c[i]    <- NROW(accrna[gene %in% ov_h3$gene & clusters == i & mean_expr_levels == l])
    unmark_c[i] <- NROW(accrna[!(gene %in% ov_h3k27$gene | gene %in% ov_h3k4$gene) & clusters == i & mean_expr_levels == l])
    # Create object for plotting
    dt <- data.table(Cluster = paste0("C", i), 
                   Mark = c("H3K4me3", "H3K27me3", "Bivalent", "Unmarked"), 
                   Proportion = c(as.integer(h3k4_c[i]), as.integer(h3k27_c[i]), as.integer(biv_c[i]), as.integer(unmark_c[i])),
                   Mean_Level = paste0("Expr Q", l))
    dt_all <- rbind(dt_all, dt)
  }
}
dt_all <- dt_all %>% .[, N := sum(Proportion), by = c("Cluster", "Mean_Level")]

p <- ggplot(dt_all, aes(fill=Mark, y=Proportion, x=Cluster)) + geom_bar(stat="identity", position="fill", alpha=1) + 
  facet_grid(. ~ Mean_Level) +
  stat_summary(fun.y = function(x){ xx <- 0; return(xx - 0.05)}, aes(label = paste0("N=", as.character(N))), geom='text', col='black', size = 3.3) +
  labs(x="Clusters", y="Relative Proportion", fill = "Histone mark") +
  scale_fill_discrete(name="Histone mark") + 
  scale_fill_brewer(palette = "Set3") + barplot_multi_theme() + theme(legend.position="none")
p
rm(ov_h3k4, ov_h3k27, ov_h3, p, i, l, unmark_c, h3k4_c, h3k27_c, biv_c, cls, mean_lev, dt, dt_all)
```
